// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io' show exitCode, stderr;
import 'dart:math';

import 'package:args/args.dart';
import 'package:csv/csv.dart';
import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:path/path.dart' as path;
import 'package:platform/platform.dart';
import 'package:snippets/snippets.dart';

const String _kHelpOption = 'help';
const String _kValidationOption = 'validation';
const String _kTrainingOption = 'training';
const String _kTrainingRatioOption = 'training-ratio';

const double _kTrainingRatio = 0.8;

/// A singleton filesystem that can be set by tests to a memory filesystem.
FileSystem filesystem = const LocalFileSystem();

/// A singleton snippet generator that can be set by tests to a mock, so that
/// we can test the command line parsing.
SnippetGenerator snippetGenerator = SnippetGenerator();

/// A singleton platform that can be set by tests for use in testing command line
/// parsing.
Platform platform = const LocalPlatform();

/// Generates snippet dartdoc output for a given input, and creates any sample
/// applications needed by the snippet.
void main(List<String> argList) {
  final ArgParser parser = ArgParser();

  parser.addOption(
    _kValidationOption,
    help: 'The output name for the generated CSV validation data.',
  );
  parser.addOption(
    _kTrainingOption,
    help: 'The output name for the generated CSV training data.',
  );
  parser.addOption(
    _kTrainingRatioOption,
    defaultsTo: '$_kTrainingRatio',
    help:
        'The proportion of data to use for the training set. The remaining data will become the validation set. Selects members in the set at random according to this ratio',
  );
  parser.addFlag(
    _kHelpOption,
    negatable: false,
    help: 'Prints help documentation for this command',
  );

  final ArgResults args = parser.parse(argList);

  if (args[_kHelpOption]! as bool) {
    stderr.writeln(parser.usage);
    exitCode = 0;
    return;
  }

  final File training = filesystem.file(args[_kTrainingOption]! as String);
  final File validation = filesystem.file(args[_kValidationOption]! as String);
  final List<File> sources = getFlutterSources();
  final List<List<Object>> content = <List<Object>>[];
  for (final File source in sources) {
    stderr.writeln('Collecting elements in ${source.path}');
    for (final SourceElement element in getFileElements(source)) {
      if (element.commentStringWithoutCode.isNotEmpty) {
        content.add(element.toList());
      }
    }
  }

  final Random rand = Random();

  final List<Object> header = <String>[
    'Class Name',
    'Name',
    'Filename',
    'Start Pos',
    'End Pos',
    'Comment String Without Code',
    'Implementation Without Comments',
    'Implementation',
    'Text',
  ];
  final List<List<Object>> trainingSet = <List<Object>>[header];
  final List<List<Object>> validationSet = <List<Object>>[header];
  final double trainingRatio = double.parse(args[_kTrainingRatioOption]! as String);

  for (final List<Object> line in content) {
    if (rand.nextDouble() >= trainingRatio) {
      validationSet.add(line);
    } else {
      trainingSet.add(line);
    }
  }

  training.writeAsStringSync(const ListToCsvConverter(delimitAllFields: true).convert(trainingSet));
  validation.writeAsStringSync(const ListToCsvConverter(delimitAllFields: true).convert(validationSet));
  exitCode = 0;
}

extension on SourceElement {
  List<Object> toList() {
    final String text =
        '### Human: Considering the following IMPLEMENTATION, rewrite a documentation comment according to the rules for writing Flutter documentation comments. ### IMPLEMENTATION: $implementationWithoutComments ### Assistant: $implementation';
    return <Object>[
      className,
      name,
      path.relative(file.absolute.path, from: FlutterInformation.instance.getFlutterRoot().absolute.path),
      startPos,
      endPos,
      commentStringWithoutCode,
      implementationWithoutComments,
      implementation,
      text,
    ];
  }
}

List<File> getFlutterSources() {
  // Just use the framework sources, not the tool, etc.
  final Directory flutter = FlutterInformation.instance
      .getFlutterRoot()
      .childDirectory('packages')
      .childDirectory('flutter')
      .childDirectory('lib');

  final List<File> dartFiles = flutter.listSync(recursive: true).whereType<File>().where((File file) {
    if (file.path.endsWith('packages/flutter/lib/src/material/icons.dart') ||
        file.path.endsWith('packages/flutter/lib/src/cupertino/icons.dart') ||
        file.basename.endsWith('.g.dart')) {
      // Don't need to collect comments in icons or autogenerated code: they're all autogenerated.
      return false;
    }
    return file.basename.endsWith('.dart');
  }).toList();

  return dartFiles;
}
